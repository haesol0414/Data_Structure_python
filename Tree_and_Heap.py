
#210904



	# 트리 (Tree)
	# 데이터의 상-하관계를 저장하는 자료 구조 = 계층적 관계
	# 예시로 컴퓨터 폴더 구조, 클래스 상속 관계 역시 계층적 관계에 속한다.
	# 배열이나 링크드 리스트는 선형적 자료 구조로 계층적 데이터를 저장하기에는 적합하지 않다.
	# 딕셔너리, 세트, 우선순위 큐 처럼 다양한 추상 자료형들을 트리를 이용해서 구현 가능하다.
	# 링크드 리스트에서는 한 노드에 데이터와 데이터의 다음 노드를 가리키는 레퍼런스를 저장하는 속성이 담겨있었다.
	# 트리노드는 하위 관계가 있는 노드들을 가리키는 레퍼런스들을 갖는다. (특정 노드의 하위 노드를 자식 노드라고 한다.)
	# 링크드 리스트에서 가장 앞에있는 노드를 haed노드 라고 부르는 것 처럼,
	# 트리에서 가장 상위계층에 있는 노드를 root노드 라고 부른다.


	# 트리 용어
	# root 노드(뿌리 노드): 트리의 시작 노드, 뿌리가 되는 노드. 보통 트리를 표현할 때 가장 위에 root 노드를 놓는 방식으로 나타냅니다.
	# 부모 노드: 특정 노드의 직속 상위 노드.
	# 자식 노드: 특정 노드의 직속 하위 노드.
	# 형제 노드: 같은 부모를 갖는 노드입니다. D와 E는 둘다 그 부모가 B죠? 이럴 때 D와 E는 서로 형제 노드입니다.
	# leaf 노드 (잎/말단 노드): 자식 노드를 갖고 있지 않은, 가장 말단에 있는 노드. 
	# 						트리의 끝에 있다고 해서 root(뿌리) 노드와 반대되는 표현으로 leaf(잎) 노드라고 부른다.
	# 깊이: 특정 노드가 root 노드에서 떨어져 있는 거리. 깊이는 해당 노드로 가기 위해서 root 노드에서 몇 번 아래로 내려와야 하는지를 나타냄.
	#	   결국 깊이라는 건 특정 노드가 root 노드로부터 얼마나 멀리 떨어져 있는지를 나타내는 것이다. 깊이는 리스트의 인덱스처럼 0 이라는 값이 존재한다.
	# 레벨: 깊이 + 1. 깊이랑 거의 똑같은 개념입. 그냥 깊이에 1을 더한 값. 레벨 1에 있는 노드들, 레벨 2에 있는 노드들… 이런식으로 특정 깊이인 노드들을 묶어서 표현할 때 사용하는 용어.
	# 높이: 트리에서 가장 깊이 있는 노드의 깊이.
	# 부분 트리 (sub-tree): 트리의 일부분을 이루고 있는 더 작은 트리. 특정 노드를 root 노드라고 생각하고 바라본다면 여러 가지 부분 트리들을 발견할 수 있다. 하나의 전체 트리에 여러 부분 트리들이 존재하는 것.



	# 이진 트리 (Binary Tree)
	# 각 노드가 최대 2개의 자식만 가질 수 있으면 이진트리라고 부른다.
	# 왼쪽 자식(Left child) & 오른쪽 자식(Right child)으로 구분한다.

	class Node:							# 이진 트리 노드 클래스
		def __init__(self,data):		# 데이터와 두 자식 노드에 대한 레퍼런스를 갖는다
			self.data = data
			self.Lchild = None			# 왼쪽 자식 레퍼런스
			self.Rchild = None			# 오른쪽 자식 레퍼런스


	# 노드 인스턴스 생성		
	root_node = Node(2)
	node_B = Node(3)
	node_C = Node(5)
	node_D = Node(7)
	node_E = Node(11)

	# B와 C를 root노드의 자식 노드로 지정 (B = 왼쪽 자식, C = 오른쪽 자식)
	root_node.Lchild = node_B
	root_node.Rchild = node_B
	# D와 E를 B노드의 자식 노드로 지정 (D = 왼쪽 자식, E = 오른쪽 자식)
	node_B.Lchild = node_D
	node_B.Rchild = node_E



	# 이진 트리의 종류
	# 포화 이진 트리(full binary tree) : 트리의 각 레벨에 노드가 꽉 차있는 이진 트리.
	# 완전 이진 트리(complete binary tree) : 높이가 k일 때 레벨 1부터 k-1까지는 노드가 모두 채워져있고, 마지막 레벨에서는 노드가 꽉 차있지 않아도 되지만 중간에 빈 곳이 있어서는 안된다.
	# 포화이진트리는 항상 완전이진트리이지만 그 역은 항상 성립하지 않는다.


	# 순회 : 자료 구조에 저장된 모든 데이터를 도는 것
	# 트리를 순회하면 계층적인 관계로 저장된 노드들을 선형적으로 나열할 수 있다.
	# pre-order 순회 ( pre : ~ 전에. 데이터를 출력하는 동작이 순회 동작 전에 있다. )
	# pre-order 순회 순서 : 현재 노드의 데이터 출력 -> 재귀적으로 왼쪽 부분 트리 순회 -> 재귀적으로 오른쪽 부분 트리 순회.
	# 전체적으로는 root 노드 출력 -> 왼쪽 부분 트리 모두 출력 -> 오른쪽 부분 트리 모두 출력
	# post-order 순회 ( post : ~ 후에. 데이터를 출력하는 동작이 순회 동작 이후에 있다. )
	# post-order 순회 순서 : 재귀적으로 왼쪽 부분 트리 순회 -> 재귀적으로 오른쪽 부분 트리 순회 -> 현재 노드의 데이터 출력
	# root 노드가 가장 마지막에 출력된다.
	# in-order 순회 ( in : ~ 안에. 데이터를 출력하는 동작이 순회 동작 사이에 있다. )
	# in-order 순회 순서 : 재귀적으로 왼쪽 부분 트리 순회 -> 현재 노드의 데이터 출력 -> 재귀적으로 오른쪽 부분 트리 순회
	# 왼쪽 부분 트리가 모두 출력 된 후 root 노드가 출력되고, 오른쪽 부분 트리가 모두 출력된다.


	# in-order 순회 함수
	def traverse_in_order(node):
	    if node is not None:	# 넘어온 파라미터 node가 None인 경우란, 현재 노드의 왼쪽 자식 노드 또는 오른쪽 자식 노드가 없다는 뜻이므로, 파라미터로 받은 node가 None이 아닐 때만 in-order 순회를 진행하면 됨.
	        traverse_in_order(node.Lchild)  # 재귀적으로 왼쪽 부분 트리 순회
	        print(node.data)  				# 데이터 출력
	        traverse_in_order(node.Rchild)  # 재귀적으로 오른쪽 부분 트리 순회
    
    







